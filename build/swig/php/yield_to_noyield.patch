diff --git transactd.yield.php transactd.yield.php
index 9e83862..cc92b95 100644
--- transactd.yield.php
+++ transactd.yield.php
@@ -1,7 +1,7 @@
 <?php
 //
 //  Transactd Client for PHP
-//      ( YIELD-VERSION : for PHP 5.5.x or later )
+//      ( NO-YIELD-VERSION : for PHP 5.4.x or older )
 //
 namespace BizStation\Transactd;
 
@@ -2545,25 +2545,18 @@ class fielddefs implements \ArrayAccess, \Countable, \IteratorAggregate {
 		return fielddefs_size($this->_cPtr);
 	}
 
-	// Generator
+	// Emulation of Generator with Iterator
 	function range($start = null, $end = null) {
 		$count = fielddefs_size($this->_cPtr);
-		if (\gettype($start) !== 'integer' || $start < 0) {
-			$i = 0;
-		} else {
-			$i = $start;
+		if ((! is_numeric($start)) || $start < 0) {
+			$start = 0;
 		}
-		if (\gettype($end) !== 'integer' || $end < 0 || $end >= $count) {
+		if ((! is_numeric($end)) || $end < 0 || $end >= $count) {
 			$end = $count - 1;
 		}
-		while ($i <= $end) {
-			$r = fielddefs_getFielddef($this->_cPtr, $i);
-			if (is_resource($r))
-				yield new fielddef($r);
-			else
-				yield $r;
-			$i++;
-		}
+		$start = (int) $start;
+		$end = (int) $end;
+		return new fielddefsIterator($this->_cPtr, $start, $end);
 	}
 
 	function __set($var,$value) {
@@ -2758,6 +2751,35 @@ class RecordIterator implements \Iterator {
 	}
 }
 
+class RecordKeyIterator extends RangeIterator {
+	private $_fielddefs = null;
+
+	function __construct($count, $fielddefs) {
+		parent::__construct(0, $count - 1);
+		$this->_fielddefs = $fielddefs;
+	}
+
+	public function current() {
+		return $this->_fielddefs->getFielddef($this->_position)->name();
+	}
+}
+
+class RecordValueIterator extends RangeIterator {
+	private $_record_cPtr = null;
+	private $_field = null;
+
+	function __construct($record_cPtr) {
+		parent::__construct(0, Record_size($record_cPtr) - 1);
+		$this->_record_cPtr = $record_cPtr;
+		$this->_field = new field();
+	}
+
+	public function current() {
+		Record_getFieldByIndexRef($this->_record_cPtr, $this->_position, $this->_field);
+		return $this->_field->getFV();
+	}
+}
+
 class Record implements \ArrayAccess, \Countable, \IteratorAggregate {
 	protected $_field = null;
 	protected $_fielddefs = null;
@@ -2810,20 +2832,13 @@ class Record implements \ArrayAccess, \Countable, \IteratorAggregate {
 		return Record_size($this->_cPtr);
 	}
 
-	// Generator
+	// Emulation of Generator with Iterator
 	function keys() {
-		$count = Record_size($this->_cPtr);
-		for ($i = 0; $i < $count; $i++) {
-			yield $this->_fielddefs->getFielddef($i)->name();
-		}
+		return new RecordKeyIterator(Record_size($this->_cPtr), $this->_fielddefs);
 	}
 
 	function values() {
-		$count = Record_size($this->_cPtr);
-		for ($i = 0; $i < $count; $i++) {
-			Record_getFieldByIndexRef($this->_cPtr, $i, $this->_field);
-			yield $this->_field->getFV();
-		}
+		return new RecordValueIterator($this->_cPtr);
 	}
 
 	// toArray
@@ -3500,6 +3515,29 @@ class RecordsetIterator implements \SeekableIterator {
 	}
 }
 
+class RecordsetRecordIterator extends RangeIterator {
+	private $_recordset_cPtr = null;
+	private $_fieldsBase_p_p = null;
+	private $_record = null;
+
+	function __construct($start, $end, $recordset_cPtr, $fielddefs) {
+		parent::__construct($start, $end);
+		$this->_recordset_cPtr = $recordset_cPtr;
+		$this->_fieldsBase_p_p = new_fieldsBase_p_p();
+		$this->_record = new Record(memoryRecord::createRecord($fielddefs));
+	}
+
+	function __destruct() {
+		delete_fieldsBase_p_p($this->_fieldsBase_p_p);
+	}
+
+	public function current() {
+		Recordset_getRow($this->_recordset_cPtr, $this->_position, $this->_fieldsBase_p_p);
+		$this->_record->_cPtr = fieldsBase_p_p_value($this->_fieldsBase_p_p);
+		return $this->_record;
+	}
+}
+
 class Recordset implements \ArrayAccess, \Countable, \IteratorAggregate {
 	private $_fieldsBase_p_p = null;
 	private $_record = null;
@@ -3547,23 +3585,18 @@ class Recordset implements \ArrayAccess, \Countable, \IteratorAggregate {
 		return $this->offsetGet($this->count() - 1);
 	}
 
-	// Generator
+	// Emulation of Generator with Iterator
 	function range($start = null, $end = null) {
 		$count = $this->count();
-		if (\gettype($start) !== 'integer' || $start < 0) {
-			$i = 0;
-		} else {
-			$i = $start;
+		if ((! is_numeric($start)) || $start < 0) {
+			$start = 0;
 		}
-		if (\gettype($end) !== 'integer' || $end < 0 || $end >= $count) {
+		if ((! is_numeric($end)) || $end < 0 || $end >= $count) {
 			$end = $count - 1;
 		}
-		while ($i <= $end) {
-			Recordset_getRow($this->_cPtr, $i, $this->_fieldsBase_p_p);
-			$this->_record->_cPtr = fieldsBase_p_p_value($this->_fieldsBase_p_p);
-			yield $this->_record;
-			$i++;
-		}
+		$start = (int) $start;
+		$end = (int) $end;
+		return new RecordsetRecordIterator($start, $end, $this->_cPtr, $this->fieldDefs());
 	}
 
 	public $_cPtr=null;
