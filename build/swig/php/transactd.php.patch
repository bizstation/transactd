diff --git transactd.php transactd.php
index daba41f..c542bf1 100644
--- transactd.php
+++ transactd.php
@@ -1,4 +1,5 @@
 <?php
+namespace BizStation\Transactd;
 
 /* ----------------------------------------------------------------------------
  * This file was automatically generated by SWIG (http://www.swig.org).
@@ -2825,6 +2826,47 @@ class fielddefs {
 }
 
 class field {
+	public function getFV() {
+		switch ($this->type()) {
+			case transactd::ft_integer:
+			case transactd::ft_uinteger:
+			case transactd::ft_autoinc:
+			case transactd::ft_autoIncUnsigned:
+			case transactd::ft_logical:
+			case transactd::ft_bit:
+				return $this->i64();
+			case transactd::ft_float:
+			case transactd::ft_decimal:
+			case transactd::ft_money:
+			case transactd::ft_numeric:
+			case transactd::ft_bfloat:
+			case transactd::ft_numericsts:
+			case transactd::ft_numericsa:
+			case transactd::ft_currency:
+				return $this->d();
+			case transactd::ft_mychar:
+			case transactd::ft_myvarchar:
+			case transactd::ft_mywchar:
+			case transactd::ft_mywvarchar:
+			case transactd::ft_mytext:
+			case transactd::ft_mydate:
+			case transactd::ft_mytime:
+			case transactd::ft_mydatetime:
+			case transactd::ft_mytimestamp:
+			case transactd::ft_date:
+			case transactd::ft_time:
+			case transactd::ft_datetime:
+			case transactd::ft_timestamp:
+				return $this->c_str();
+			case transactd::ft_string:
+			case transactd::ft_myvarbinary:
+			case transactd::ft_mywvarbinary:
+			case transactd::ft_myblob:
+				return $this->getBin();
+		}
+		return null;
+	}
+
 	public $_cPtr=null;
 	protected $_pData=array();
 
@@ -2863,7 +2905,7 @@ class field {
 		return field_blobLenBytes($this->_cPtr);
 	}
 
-	function __construct($ptr,$fd,$fds) {
+	function __construct($ptr,$fd = null,$fds = null) {
 		if (is_resource($ptr) && get_resource_type($ptr) === '_p_bzs__db__protocol__tdap__client__field') {
 			$this->_cPtr=$ptr;
 			return;
@@ -3005,7 +3047,149 @@ abstract class fieldsBase {
 	}
 }
 
-class Record extends fieldsBase {
+class RecordIterator implements \Iterator {
+	private $_record_cPtr = null;
+	private $_position = 0;
+	private $_count = -1;
+	private $_field = null;
+	private $_fielddefs = null;
+
+	function __construct($record_cPtr, $fielddefs) {
+		$this->_record_cPtr = $record_cPtr;
+		$this->_position = 0;
+		$this->_count = fieldsBase_size($record_cPtr);
+		$this->_field = field::createDummyField();
+		$this->_fielddefs = $fielddefs;
+	}
+
+	function __destruct() {
+		field::deleteField($this->_field);
+	}
+
+	public function rewind() {
+		$this->_position = 0;
+	}
+
+	public function valid() {
+		return $this->_position < $this->_count;
+	}
+
+	public function current() {
+		fieldsBase_getFieldByIndex($this->_record_cPtr, $this->_position, $this->_field);
+		return $this->_field->getFV();
+	}
+
+	public function key() {
+		return $this->_fielddefs->getFielddef($this->_position)->nameA();
+	}
+
+	public function next() {
+		$this->_position++;
+	}
+}
+
+class Record extends fieldsBase implements \ArrayAccess, \Countable, \IteratorAggregate {
+	private $_field = null;
+	private $_fielddefs = null;
+
+	function __clone() {
+		$this->_field = field::createDummyField();
+	}
+
+	function __destruct() {
+		field::deleteField($this->_field);
+	}
+
+	// IteratorAggregate
+	public function getIterator() {
+		return new RecordIterator($this->_cPtr, $this->_fielddefs);
+	}
+
+	// ArrayAccess
+	public function offsetExists($offset) {
+		switch (\gettype($offset)) {
+			case "integer":
+				return $offset >= 0 && $offset < $this->count();
+			case "string":
+				return fieldsBase_indexByName($this->_cPtr, $offset) >= 0;
+			default:
+				return false;
+		}
+	}
+
+	public function offsetGet($offset) {
+		switch (\gettype($offset)) {
+			case "integer":
+				fieldsBase_getFieldByIndex($this->_cPtr, $offset, $this->_field);
+				break;
+			case "string":
+				fieldsBase_getFieldByName($this->_cPtr, $offset, $this->_field);
+				break;
+			default:
+				throw new \OutOfRangeException();
+		}
+		return $this->_field->getFV();
+	}
+
+	public function offsetSet($offset, $value) {
+		throw new \BadMethodCallException();
+	}
+
+	public function offsetUnset($offset) {
+		throw new \BadMethodCallException();
+	}
+
+	// Countable
+	public function count() {
+		return fieldsBase_size($this->_cPtr);
+	}
+
+	// generator
+	function keys() {
+		$count = fieldsBase_size($this->_cPtr);
+		for ($i = 0; $i < $count; $i++) {
+			yield $this->_fielddefs->getFielddef($i)->nameA();
+		}
+	}
+
+	function values() {
+		$count = fieldsBase_size($this->_cPtr);
+		for ($i = 0; $i < $count; $i++) {
+			fieldsBase_getFieldByIndex($this->_cPtr, $i, $this->_field);
+			yield $this->_field->getFV();
+		}
+	}
+
+	// toArray
+	function keysArray() {
+		$ret = array();
+		$count = fieldsBase_size($this->_cPtr);
+		for ($i = 0; $i < $count; $i++) {
+			$ret[] = $this->_fielddefs->getFielddef($i)->nameA();
+		}
+		return $ret;
+	}
+
+	function valuesArray() {
+		$ret = array();
+		$count = fieldsBase_size($this->_cPtr);
+		for ($i = 0; $i < $count; $i++) {
+			fieldsBase_getFieldByIndex($this->_cPtr, $i, $this->_field);
+			$ret[] = $this->_field->getFV();
+		}
+		return $ret;
+	}
+
+	function toArray() {
+		$ret = array();
+		$count = fieldsBase_size($this->_cPtr);
+		for ($i = 0; $i < $count; $i++) {
+			fieldsBase_getFieldByIndex($this->_cPtr, $i, $this->_field);
+			$ret[$this->_fielddefs->getFielddef($i)->nameA()] = $this->_field->getFV();
+		}
+		return $ret;
+	}
+
 	public $_cPtr=null;
 
 	function __set($var,$value) {
@@ -3024,6 +3208,8 @@ class Record extends fieldsBase {
 	}
 	function __construct($h) {
 		$this->_cPtr=$h;
+		$this->_field = field::createDummyField();
+		$this->_fielddefs = $this->fieldDefs();
 	}
 
 	static function createRecord($fdinfo) {
@@ -3083,7 +3269,126 @@ class writableRecord extends Record {
 	}
 }
 
-class RecordSet {
+class RecordSetIterator implements \SeekableIterator {
+	private $_recordset_cPtr = null;
+	private $_position = 0;
+	private $_memoryRecord_p_p = null;
+	private $_record = null;
+	private $_count = -1;
+
+	function __construct($recordset_cPtr, $fielddefs) {
+		$this->_recordset_cPtr = $recordset_cPtr;
+		$this->_position = 0;
+		$this->_memoryRecord_p_p = new_memoryRecord_p_p();
+		$this->_count = RecordSet_count($recordset_cPtr);
+		$this->_record = Record::createRecord($fielddefs);
+	}
+
+	function __destruct() {
+		delete_memoryRecord_p_p($this->_memoryRecord_p_p);
+	}
+
+	public function rewind() {
+		$this->_position = 0;
+	}
+
+	public function valid() {
+		return $this->_position < $this->_count;
+	}
+
+	public function current() {
+		RecordSet_getRow($this->_recordset_cPtr, $this->_position, $this->_memoryRecord_p_p);
+		$this->_record->_cPtr = memoryRecord_p_p_value($this->_memoryRecord_p_p);
+		return $this->_record;
+	}
+
+	public function key() {
+		return $this->_position;
+	}
+
+	public function next() {
+		$this->_position++;
+	}
+
+	public function seek($position) {
+		if ($position < 0 || $position >= $this->_count) {
+			throw new \OutOfBoundsException("invalid seek position ($position)");
+		}
+		$this->_position = $position;
+	}
+}
+
+class RecordSet implements \ArrayAccess, \Countable, \IteratorAggregate {
+	private $_memoryRecord_p_p = null;
+	private $_record = null;
+
+	function __clone() {
+		$this->_memoryRecord_p_p = new_memoryRecord_p_p();
+		$this->_record = Record::createRecord($this->fieldDefs());
+	}
+
+	function __destruct() {
+		transactd::delete_memoryRecord_p_p($this->_memoryRecord_p_p);
+	}
+
+	// IteratorAggregate
+	public function getIterator() {
+		return new RecordSetIterator($this->_cPtr, $this->fieldDefs());
+	}
+
+	// ArrayAccess
+	public function offsetExists($offset) {
+		return \gettype($offset) !== 'integer' && $offset >= 0 && $offset < $this->count();
+	}
+
+	public function offsetGet($offset) {
+		RecordSet_getRow($this->_cPtr, $offset, $this->_memoryRecord_p_p);
+		$this->_record->_cPtr = memoryRecord_p_p_value($this->_memoryRecord_p_p);
+		return $this->_record;
+	}
+
+	public function offsetSet($offset, $value) {
+		throw new \BadMethodCallException();
+	}
+
+	public function offsetUnset($offset) {
+		throw new \BadMethodCallException();
+	}
+
+	// random access
+	function first() {
+		if ($this->count() <= 0) {
+			throw new \OutOfBoundsException('no records in recordset');
+		}
+		return $this->offsetGet(0);
+	}
+
+	function last() {
+		if ($this->count() <= 0) {
+			throw new \OutOfBoundsException('no records in recordset');
+		}
+		return $this->offsetGet($this->count() - 1);
+	}
+
+	// generator
+	function range($start = null, $end = null) {
+		$count = $this->count();
+		if (\gettype($start) !== 'integer' || $start < 0) {
+			$i = 0;
+		} else {
+			$i = $start;
+		}
+		if (\gettype($end) !== 'integer' || $end < 0 || $end >= $count) {
+			$end = $count - 1;
+		}
+		while ($i <= $end) {
+			RecordSet_getRow($this->_cPtr, $i, $this->_memoryRecord_p_p);
+			$this->_record->_cPtr = memoryRecord_p_p_value($this->_memoryRecord_p_p);
+			yield $this->_record;
+			$i++;
+		}
+	}
+
 	public $_cPtr=null;
 	protected $_pData=array();
 
@@ -3105,9 +3410,13 @@ class RecordSet {
 	function __construct($res=null) {
 		if (is_resource($res) && get_resource_type($res) === '_p_recordset') {
 			$this->_cPtr=$res;
+			$this->_memoryRecord_p_p = new_memoryRecord_p_p();
+			$this->_record = Record::createRecord($this->fieldDefs());
 			return;
 		}
 		$this->_cPtr=new_RecordSet();
+		$this->_memoryRecord_p_p = new_memoryRecord_p_p();
+		$this->_record = Record::createRecord($this->fieldDefs());
 	}
 
 	function uniqueReadMaxField() {
@@ -3355,6 +3664,32 @@ class groupQuery {
 }
 
 class ActiveTable {
+	function keyValue($kv0,$kv1=null,$kv2=null,$kv3=null,$kv4=null,$kv5=null,$kv6=null,$kv7=null) {
+		$args = \func_get_args();
+		$params = array();
+		$end_args = false;
+		for ($i = 0; $i < \func_num_args(); $i++) {
+			switch (\gettype($args[$i])) {
+				case 'string':
+					$params[] = $args[$i]; break;
+				case 'NULL':
+					$end_args = true; break;
+				default:
+					$params[] = (string) $args[$i]; break;
+			}
+			if ($end_args) {
+				break;
+			}
+		}
+		return call_user_func_array(array($this, '_keyValue'), $params);
+	}
+
+	function read($queryBase) {
+		$rs = new RecordSet();
+		$this->read_rs($rs, $queryBase);
+		return $rs;
+	}
+
 	public $_cPtr=null;
 	protected $_pData=array();
 
@@ -3376,7 +3711,7 @@ class ActiveTable {
 		return $this->_pData[$var];
 	}
 
-	function __construct($db,$tableName) {
+	function __construct($db,$tableName = null) {
 		if (is_resource($db) && get_resource_type($db) === '_p_bzs__db__protocol__tdap__client__activeTableT_map_orm_map_orm__mdl_typename_map_orm__fdi_typename_t') {
 			$this->_cPtr=$db;
 			return;
